[TOC]

## 问答题考点

### 简单替换密码(P57)

#### 例题一

<img src="%E7%AC%94%E8%AE%B0.assets/image-20241223193016743.png"  alt="image-20241223193016743"  style="zoom:50%;"/>

(1)vhfxulwb

(2)$$f^{-1}(c)=(c-k) \mod  n$$

(3)

```python
defcaesar_cipher(text,key,encrypt=True):
result=""
forcharintext:
ifchar.isalpha():#Checkifthecharacterisaletter
shift=1ifencryptelse-1
start=ord('a')ifchar.islower()elseord('A')
#Shiftcharacterandwraparoundthealphabet
result+=chr((ord(char)-start+shift*key)%26+start)
else:
result+=char#Non-alphabetcharactersareaddedasis
returnresult

#Exampleusage:
plaintext="security"
key=3

#Encrypt
ciphertext=caesar_cipher(plaintext,key)
print("Encrypted:",ciphertext)

#Decrypt
decrypted_text=caesar_cipher(ciphertext,key,encrypt=False)
print("Decrypted:",decrypted_text)
```

#### 例题二

<img src="%E7%AC%94%E8%AE%B0.assets/image-20241223195257672.png" alt="image-20241223195257672" style="zoom:50%;"/>

<img src="%E7%AC%94%E8%AE%B0.assets/1734956097279-17349562067611.jpg" style="zoom:25%;"/>

#### 例题三

<img src="%E7%AC%94%E8%AE%B0.assets/image-20241223201739247.png" alt="image-20241223201739247" style="zoom:50%;"/>

<img src="%E7%AC%94%E8%AE%B0.assets/image-20241223203322321.png" alt="image-20241223203322321" style="zoom:50%;"/>

<img src="%E7%AC%94%E8%AE%B0.assets/image-20241223203350772.png" alt="image-20241223203350772" style="zoom:50%;"/>

#### 例题四

<img src="%E7%AC%94%E8%AE%B0.assets/image-20241223203459286.png" alt="image-20241223203459286" style="zoom:50%;"/>

(1)加密后的密文

首先，我们需要将明文 "security" 和密钥 "dog" 转换为它们在字母表中的位置（a = 0, b = 1,..., z = 25）。然后，使用加密函数 $$f(p_i)=(p_i+k_i) mod 26$$ 来加密每个字母。

明文 "security" 的位置：19,4,2,20,17,9,19,24
密钥 "dog" 的位置：3,14,6,6,14,6

由于密钥长度比明文短，我们需要重复密钥 "dogdog" 来匹配明文的长度。

加密过程如下：
- 's'(19)+'d'(3)= 22->'w'
- 'e'(4)+'o'(14)= 18->'s'
- 'c'(2)+'g'(6)= 8->'i'
- 'u'(20)+'d'(3)= 23->'x'
- 'r'(17)+'o'(14)= 31-> 5->'f'(因为 31 mod 26 = 5)
- 'i'(9)+'g'(6)= 15->'p'
- 't'(19)+'d'(3)= 22->'w'
- 'y'(24)+'o'(14)= 38-> 12->'m'(因为 38 mod 26 = 12)

加密后的密文是 "wsixfpwm"。

(2)解密函数

解密函数是加密函数的逆过程，可以表示为 $f^{-1}(c_i)=(c_i-k_i) \mod 26$，其中 $c_i$ 是密文字母在字母表中的位置。

(3)高级语言编写通用 Vigenere 密码的加密/解密程序

这里提供一个 Python 程序示例，用于实现 Vigenere 密码的加密和解密：

```python
defvigenere_cipher(text,key,encrypt=True):
result=""
key_length=len(key)
key_as_int=[ord(k)-65forkinkey.upper()]#Convertkeytointegerpositions

fori,charinenumerate(text.upper()):
ifchar.isalpha():#Checkifthecharacterisaletter
char_int=ord(char)-65
shift=key_as_int[i%key_length]#Usethekey 循环
ifencrypt:
result+=chr((char_int+shift)%26+65)
else:
result+=chr((char_int-shift)%26+65)
else:
result+=char#Non-alphabetcharactersareaddedasis

returnresult

#Exampleusage:
plaintext="security"
key="dog"

#Encrypt
ciphertext=vigenere_cipher(plaintext,key)
print("Encrypted:",ciphertext)

#Decrypt
decrypted_text=vigenere_cipher(ciphertext,key,encrypt=False)
print("Decrypted:",decrypted_text)
```

这个程序定义了一个 `vigenere_cipher` 函数，它接受明文、密钥和加密标志（默认为加密）。如果 `encrypt` 参数为 `False`，则执行解密操作。程序中还包含了一个示例，展示了如何使用这个函数来加密和解密文本。

### DES 算法原理(P17-24)

<img src="%E7%AC%94%E8%AE%B0.assets/image-20241223211852585.png" alt="image-20241223211852585" style="zoom:50%;"/>

1. 初始置换
2. 左右分组
3. 密钥置换后分左右组，每轮循环左移 1 位或两位
4. 明文扩展置换
5. 选出 48 位密钥合并后与明文异或
6. 使用 8 个 s 盒代替
7. p 盒置换后与明文左分组异或作为右分组
8. 命名原右分组作为左分组
9. 重复 3-8 步骤，16 轮
10. 逆初始置换

### RSA 算法过程(P40-41)

1. 选两个质数 p, q
2. 质数相乘 $N=p \times q$
3. 欧拉函数 $T=(p-1) \times (q-1)$
4. 选公钥 E 质数；$1<E<T$; 不是 T 的因子
5. 算私钥 D $(D \times  E) \mod T=1$（乘逆）
6. 公钥(E, N)密钥(D, N)
7. 加密 $明文^E \mod N=密文$
8. 解密 $密文^D \mod N=明文$

#### 平方乘算法

<img src="%E7%AC%94%E8%AE%B0.assets/image-20241223215115783.png" alt="image-20241223215115783" style="zoom:50%;"/>

### 基于公开密钥的数字签名方案(P61)

<img src="%E7%AC%94%E8%AE%B0.assets/image-20241223220529031.png" alt="image-20241223220529031" style="zoom:50%;"/>

公钥加密，私钥解密；私钥签名，公钥验签。

### 单向散列函数的特点(P62-63)

Hash 函数的作用是当输入一任意长度的信息 M 时，将输出一个固定长度为 m 的散列值 h。即 h＝h（M）

安全的 Hash 函数的特点如下。
（1）Hash 函数能从任意长度的 M 中产生固定长度的散列值 h。
（2）已知 M 时，利用 h（M）很容易计算出 h。
（3）已知 M 时，要想通过同一个 h（M）计算出不同的 h 是很困难的。
（4）已知 h 时，要想从 h（M）中计算出 M 是很困难的。
（5）已知 M 时，要找出另一信息 M＇，使 h（M）＝h（M＇）是很困难的。

### 简述信息的完整性、可用性、保密性(P4)

（1）**完整性。保护计算机系统内软件和数据不被偶然或人为蓄意地破坏、篡改、伪造等。**

（2）**可用性。在用户授权的情况下，无论什么时候，只要用户需要，信息必须是可用的和可访问的，信息系统不能拒绝服务。**

（3）**保密性。信息必须按照拥有者的要求保持一定的秘密性。**

### 请简述数字水印的主要特性(P52)

1.**稳定性 稳定性是指水印信息能够抵抗应用过程中的各种破坏。**

2.**水印容量水印容量是指在数字信息中加入的水印数量。**

3.**安全性 安全性是指加入水印和检测水印的方法对没有授权的第三方应是绝对保密的，而且不可轻易破解。**

4.**自恢复性 自恢复性是指在原始数据经过较大的破坏或变换后，仍能从原始数据中恢复出隐藏的水印。**

5.**不可见性 不可见性对可感知的数字水印来说，是指数字信息加入水印后不会改变其感知效果，即看不到数字水印的存在，这是数字水印最基本的特点。**

### 论述公开密钥算法的典型特点(P37-38)

（1）在公开密钥算法中，有一对密钥（pk，sk），其中 pk（publickey）是公开的，即公开密钥，简称公钥。公开密钥可以在密钥簿上查找，就像电话号码可以在电话号码簿上查找一样，公开密钥可以用来加密或解密。另一个密钥 sk(privatekey）是保密的，这个保密密钥称为私人密钥，简称私钥，私人密钥也可以用来加密或解密。

（2）在公开密钥算法中，进行加密和解密时使用不同的加密密钥和解密密钥，而且加密密钥或解密密钥不能相互推导出来，或者很难相互推导出来。

（3）在公开密钥算法中，公开密钥和私人密钥必须配对使用。也就是说，如果使用公开密钥加密，就必须使用相应的私人密钥解密；如果使用私人密钥加密，也必须使用相应的公开密钥解密。

（4）一般来说，公开密钥算法都是建立在严格的数学基础上的，公开密钥和私人密钥也是通过数学方法产生的。公开密钥算法的安全性建立在某个数学问题很难解决的基础上。

### 论述对称加密体制(P49)

（1）在对称加密体制中，如果有 N 个成员，就需要 N（N—1）/2 个密钥，这巨大的密钥量给密钥的分配和安全管理带来了困难。

（2）在对称加密体制中，知道了加密过程就很容易推导出解密过程，知道了加密密钥就等于知道了解密密钥，可以用简单的方法随机产生密钥。

（3）多数对称加密算法不是建立在严格意义的数学问题上的，而是基于多种“规则”和可“选择”的假设。

（4）用对称加密算法传送信息时，通信双方在开始通信之前必须约定使用同一密钥，这就带来了密钥在传递过程中的安全问题，所以必须建立受保护的通道来传递密钥。

（5）对称加密算法不能提供法律证据，不具备数字签名功能。

（6）对称加密算法加密速度快，这也是其唯一的重要优点，通常用对称加密算法加密大量的明文。

### 论述公开密钥体制(P49)

（1）在公开密钥体制中，每个成员都有一对密钥（pk，sk）。如果有 N 个成员，只需要 2N 个密钥，需要的密钥少，密钥的分配和安全管理相对容易一些。

（2）知道加密过程不能推导出解密过程，不能从 pk 推导出 sk，或从 sk 推导出 pk。或者说，如果能推导出来也是很困难的，要花很长的时间和很大的代价。

（3）容易用数学语言描述，算法的安全性是建立在已知数学问题求解困难的假设基础上的。

（4）需要一个有效的计算方法求解一对密钥 pk、sk，以确保不能从 pk、sk 中相互推导。

（5）用公开密钥算法传送信息时，无须在通信双方传递密钥，也就不需要建立受保护的信息通道。这是公开密钥算法最大的优势，使得数字签名和数字认证成为可能。公开密钥算法有着更广阔的应用范围。

（6）就目前来看，公开密钥算法加密的速度要比对称加密算法慢得多。一般只用公开密钥算法加密安全要求高、信息量不大的信息。

### 简述什么是数字证书？X.509 数字证书包含哪些内容？

数字证书（Digital Certificate）是由权威机构 CA 发行的一种权威性的电子文档，是网络环境中的一种身份证，用于证明某一用户的身份以及其公开密钥的合法性。

一个标准的 X.509 数字证书包含版本号、序列号、签名算法标识符、认证机构、有效期、主体、主体公开密钥信息、CA 的数字签名、可选项等。

（1）证书版本号：指出该证书使用了哪种版本的 X.509 标准。

（2）证书序列号：CA 会给每一个证书分配唯一的证书序列号。

（3）证书签名算法标识符：用来指定 CA 签发证书时所使用的公开密钥算法和 Hash 算法。

（4）证书认证机构：证书的发行机构名称，命名规则一般采用 X.500 格式。

（5）证书有效期：证书起始时间及终止时间，指明证书在这两个时间段内有效。

（6）证书所有人的名称：命名规则一般采用 X.500 格式。

（7）证书所有人的公开密钥信息：包括证书持有人的公钥、算法的标识符和其他相关的密钥参数。

（8）CA 的数字签名：这是使用发布者私钥生成的签名，以确保这个证书在发放之后没有被篡改。

（9）可选项：签发者唯一标识、证书持有人唯一标识符等都是可选项，可根据需要进行选择。

### 论述网络攻击的一般步骤(PPT 第六讲)

![image-20241224181019187](%E7%AC%94%E8%AE%B0.assets/image-20241224181019187.png)

![image-20241224181051813](%E7%AC%94%E8%AE%B0.assets/image-20241224181051813.png)

![image-20241224181108233](%E7%AC%94%E8%AE%B0.assets/image-20241224181108233.png)

![image-20241224181121997](%E7%AC%94%E8%AE%B0.assets/image-20241224181121997.png)

![image-20241224181136200](%E7%AC%94%E8%AE%B0.assets/image-20241224181136200.png)

![image-20241224181206960](%E7%AC%94%E8%AE%B0.assets/image-20241224181206960.png)

![image-20241224181236129](%E7%AC%94%E8%AE%B0.assets/image-20241224181236129.png)



### 论述计算机病毒程序的一般构成(P96)

病毒程序一般由 3 个基本模块组成，即安装模块、传染模块和破坏模块。对每一个病毒程序来说，安装模块、传染模块是必不可少的，而破坏模块可以直接隐含在传染模块中，也可以单独构成一个模块。

1.安装模块

用户不会主动运行一个病毒程序，因此，病毒程序必须通过自身实现自启动并安装到计算机系统中。不同类型的病毒程序会使用不同的安装方法。

2.传染模块

传染模块包括以下 3 部分内容。

（1）传染控制部分。病毒一般都有一个控制条件，一旦满足这个条件就开始感染。例如，病毒先判断某个文件是否是 EXE 文件，如果是再进行传染，否则将寻找下一个文件。

（2）传染判断部分。每个病毒程序都有一个标记，在传染时将判断这个标记，如果磁盘或者文件已经被传染则不再传染，否则就进行传染。

（3）传染操作部分。在满足传染条件时进行传染操作。

3.破坏模块

计算机病毒的最终目的是进行破坏，其破坏的基本手段就是删除文件或数据。破坏模块包括两部分：一是激发控制，当病毒满足一个条件，例如满足“某月 13 日，并且是星期五”时病毒就发作；另一个就是破坏操作，不同病毒有不同的操作方法，典型的恶性病毒的操作方法是疯狂复制、删除文件等。

### 论述杀毒软件的一般构成(P101-102)

计算机杀毒软件一般由用户界面模块、病毒数据库、病毒扫描引擎、文件实时监控模块和进程实时监控模块等部分组成。

1.用户界面模块

用户界面直接面向用户，主要功能包括提供杀毒软件的基本设置，如病毒库升级设置、多引擎设置等；软件运行时，可以打开或关闭相应的实时监控模块；监控模块发现病毒后，将病毒的信息展示给用户；扫描病毒时响应用户的命令，如暂停、继续、关闭等。

2.病毒数据库

病毒数据库存储对病毒特征码源文件进行加密和压缩处理后得到的特征码目标文件。病毒特征码目标文件主要包括文件头和数据体两部分。文件头包含病毒特征码的版本、加载日期等信息，数据体包含病毒的特征码值以及病毒名。常见的特征码目标文件的组织格式是将病毒特征码和病毒名捆绑存放，这有利于病毒库查询并提高处理速度。

3.病毒扫描引擎

病毒扫描引擎主要包括文件解析模块、病毒扫描模块、特征码加载模块等。

（1）文件解析模块包括文件夹检测模块、文件类型检测模块和文件读取模块。文件夹检测模块负责识别输入对象的类型，如果是文件，则进行下一步操作；如果是文件夹，则读取它下面的文件夹或文件再进行处理。文件类型检测模块判断文件是否经过压缩等，如果是压缩文件，则解压缩后再进行处理；文件读取模块将每一个文件转换成二进制数据流，交由病毒扫描模块进行特征码匹配。

（2）病毒扫描模块的主要功能是提取文件的特征码，与病毒库中的病毒特征码进行比较，根据匹配结果进行处理。如果发现病毒，则提交异常事件，通知用户。

（3）特征码加载模块主要负责将病毒特征码目标文件加载到病毒数据库中，并对病毒数据库进行维护。

4.文件实时监控模块

文件实时监控模块主要针对通过网络、移动设备下载到本地计算机的病毒，或进入系统后释放出的病毒文件。不管病毒文件以什么方式进入系统，文件实时监控模块都能检测到文件的变化并给出通知。如果发现文件变化，则将文件提交给病毒扫描模块，扫描文件是否有病毒并做出相应处理。

5.进程实时监控模块

进程实时监控模块主要用来监控系统中的所有任务和进程，并且能通过它们的进程 ID 直接定位到文件系统的宿主文件上。当发现有新的进程行为异常时，直接对其可执行文件进行扫描，如果发现病毒，则立刻终止该进程并通知用户。

### 在软件系统中，要安全地保护用户的密码，应该采取哪些措施

1. 使用随机生成密钥作为用户密码
2. 如果允许用户选择口令，最佳的方法是基于短语选择
3. 进行弱口令测试和定期修改密码
4. 使用哈希值并加盐来存储密码

### 设计软件保护的一般性建议（P289）

(1)软件发行之前一定要对可执行程序进行加壳, 使得破解者无法直接修改程序。

(2)要在自己编写的软件中嵌入反跟踪代码, 以增加软件的安全性。

(3)增加对软件自身的完整性检查。这包括对磁盘文件和内存映像的检查, 以防止有人未经允许修改程序, 以达到破解的目的。

(4)不要采用一目了然的名字来命名与软件保护相关的函数和文件。

(5)当检测到软件破解企图之后过一段时间后使软件停止工作。

(6)不要依赖于类似 GetLocalTime()、GetSystemTime()这些众所周知的函数来获取系统时间, 可以通过读取关键的系统文件的修改时间来得到系统时间。

(7)给软件保护加入一定的随机性。在软件运行的树个时刻随机地检查注册码。

(8)如果试用版与正式版是分开的两个版本应彻底删除相关的代码。

(9)如果软件中包含驱动程序, 则最好将保护判断加在驱动程序中。

(10)将注册码、安装时间记录在多个不同的地方。

(11)采用一机一码, 可以防止注册码传播。

(12)最好采用成熟的密码学算法。

(13)可以采用在线注册的方法。

(14)注册文件的尺寸不能太小。

### 什么是区块链技术？它有哪些特点？（PPT 第 8 讲）

区块链是一种分布式账本技术，它允许多个参与者在没有中央权威的情况下，共同维护一个不断增长的数据记录列表。这些数据记录被称为区块，它们通过密码学方法相互链接，确保了数据的完整性和不可篡改性。

以下是区块链的一些关键特性：

1. 去中心化：区块链不依赖于单一的中心化实体，而是由网络中的所有参与者共同维护。这减少了单点故障的风险，并提高了系统的抗审查性。
2. 不可篡改性：一旦区块被添加到区块链上，就几乎不可能更改或删除。这是因为每个区块都包含前一个区块的哈希值，任何对数据的更改都会导致后续所有区块的哈希值发生变化，这在计算上是非常困难的。
3. 完全匿名：在区块链世界里，所有的账户（或者说“钱包”）都是通过一个密码来访问。如果你失去了密码，也就失去了账户里面的所有货币。

### 什么是社会工程学攻击？常见的攻击手段有哪些？（PPT 第 11 讲）

现实社会中的欺骗手段一旦被黑客延伸应用到攻击网络系统，就发展为社会工程学攻击。

1. 环境渗透
2. 引诱
3. 伪装
4. 说服
5. 恐吓
6. 恭维
7. 反向社会工程学攻击

### 请论述常见的软件安全问题

1. 系统软件安全问题
2. 应用软件安全问题
3. 第三方代码安全问题
4. 新技术安全问题

### 请论述在软件开发的各阶段需要考虑的安全问题

![image-20241224185553629](%E7%AC%94%E8%AE%B0.assets/image-20241224185553629.png)

![image-20241224185627104](%E7%AC%94%E8%AE%B0.assets/image-20241224185627104.png)

### 请论述 Web 应用系统的安全功能设计方案

一个基本 Web 应用系统有终端用户、网络、主机系统、应用程序、数据这 5 个层次。信息系统在安全防护设计过程中应从这 5 个层面进行针对性的安全设计。

1. 终端安全防护：办公计算机终端、移动作业终端和信息采集类终端。
2. 应用安全设计：
   1. 应用安全功能设计：身份认证、授权、输入和输出验证配置管理、会话管理、参数操作、异常管理、审核与日志
   2. 应用交互安全设计：明确交互系统、接口方式安全设计
3. 数据安全设计
   1. 机密性要求：数据传输应确保保密性、数据使用应确保保密性、数据删除应确保保密性
   2. 完整性要求：数据传输应确保完整性、数据使用应确保完整性。
   3. 可用性要求: 数据采集应确保可用性、数据传输应确保可用性、数据处理应确保可用性、数据使用应确保可用性

### 操作系统的安全设计的原则(P211)

(1)**最小权限**。每个用户及程序应使用尽可能小的权限工作, 这样, 由攻击者恶意攻击造成的破坏程度会降到最低。

(2)**机制的经济性**。保护系统的设计应是小型化的, 这样, 安全系统就能被完全检测其可信性。

(3)**开放式设计**。保护机制必须是独立设计的, 它必须能够防止所有潜在攻击者的攻击; 它也必须是公开的, 仅依赖于一些保密信息。

(4)**权限分离**。对实体(即计算机系统中的资源)的存取应该不只是依赖于某一个条件, 这样攻击者将不会拥有对系统全部资源的存取权。

(5)**最少通用机制**。可共享实体提供了信息流的潜在通道, 系统为防止这种共享的威胁, 要采取物理或逻辑分离的措施。

