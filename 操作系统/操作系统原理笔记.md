# 操作系统复习笔记

题目：

- 单选 3'*10
- 问答 10' * 7

问答 8 抽 7

- [x] 进程同步
- [x] [作业调度与进程调度](# 调度算法)
- [x] [银行家算法](# 银行家算法)
- [x] 伙伴系统
- [ ] 分页系统分段系统的地址转换
- [ ] 页面置换
- [ ] 磁盘调度
- [x] [实时调度](# 实时调度)

## 引论

### 操作系统的目标

　　1. 方便性
　　1. 有效性: 提高系统资源的利用率和吞吐量
　　1. 可扩充性：微内核结构，方便地增添新功能和模块，以及对原有功能和模块进行修改
　　1. 开放性

### 操作系统的作用

1. 人机交互：OS 作为 用户与计算机硬件系统之间的接口
   1. 命令方式
   2. 系统调用方式
   3. 图形/窗口方式
2. 资源管理：OS 作为计算机系统资源的管理者
   1. 处理机：负责处理机的分配与控制
   2. 存储器：负责内存的分配与回收
   3. IO设备：负责IO设备的分配与操纵
   3. 文件管理：实现对文件的存取、共享、保护
3. 资源抽象：：OS实现了对计算机资源的抽象

### 操作系统发展的动力

1. 不断提高计算机系统的资源利用率
2. 方便用户
3. 器件不断更新迭代
4. 计算机体系结构不断发展
5. 不断提出新的应用需求

### 操作系统发展的过程

#### 单道批处理系统

缺点：资源得不到充分利用

#### 多道批处理

优点：

- 资源利用率高
- 系统吞吐量大

缺点：

- 平均周转时间长
- 无交互能力

周转时间：指一项作业提交给系统到执行结束的时间

#### 操作系统的定义

OS是一组能游戏笑傲地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合。

#### 分时系统

能够**人机交互**和**共享主机**

特征：

- 多路型
- 独立性
- 及时性
- 交互性

#### 实时系统

及时完成某些作业

截止时间：

- 开始截止时间：某任务在某时刻前必须开始执行
- 完成结束及时：某任务在某时刻前必须结束执行

硬实时：必须满足限定时间

软实时：可以偶尔不满足限定时间

#### 微机操作系统

1. 单用户单任务OS：MS-DOS
2. 单用户多任务OS：win98
3. 多用户多任务OS：UNIX、类UNIX、Windows NT

#### 嵌入式操作系统

特点：

- 系统内核小
- 系统精简
- 实时性高
- 具有可配置性

#### 网络操作系统

用于对网络资源进行管理和控制、实现数据通信及对网络资源的共享，为用户提供网络资源接口的彝族软件和规程的集合

#### 分布式操作系统

### 操作系统的基本特性

#### 并发

提高利用率，增加系统吞吐量

- 并发：多个事件在同一时间间隔内发生
- 并行：多个事件在同一时刻发生

引入进程实现并发

#### 共享

指系统中的资源可供内存中多个并发执行的进程共同使用。

- 互斥共享：在一段时间内之允许一个进程访问的资源，称为临界资源，只能被互斥地访问
- 同时共享：宏观上可以有多个进程同时访问，微观上交替进行。

#### 虚拟

时分复用、空分复用

#### 异步

程序以人们不可预知的速度向前推进

### 操作系统内核

- 支撑功能：中断处理、时钟管理、原语操作
- 资源管理功能：进程管理、存储器管理、设备管理
- 双重工作模式：内核态与用户态

### 操作系统的主要功能

#### 处理机管理

1. 进程控制
2. 进程 同步
3. 进程通信
4. 调度：作业调度（分配资源，调度进内存的就绪队列）、进程调度（从就绪队列中调度进处理机执行）

#### 存储器管理

1. 内存分配与回收
2. 内存保护
3. 地址映射
4. 内存扩充

### 操作系统结构

1. 模块化：低耦合高内聚
2. 分层式：系统效率低
3. 微内核：基于C/S模式

## 调度算法

### 作业调度

#### 先来先服务（FCFS）

#### 短作业优先（SJF）

#### 高响应比优先（HRRN）

$ 优先级 = \frac {等待时间 + 要求服务时间}{要求服务时间} $


### 进程调度

#### 轮转法

按先来先服务的顺序分配时间片

#### 优先级算法

- 静态优先级
- 动态优先级

#### 多级反馈队列算法

![image-20250102210536471](./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0.assets/image-20250102210536471.png)

每个队列内按先来先服务调度

队列间用优先级调度

#### 基于公平原则的调度算法

##### 保证调度

按照进程数量均分

### 实时调度

#### 分类

任务类型：硬实时和软实时

抢占类型：抢占式和非抢占式

抢占式又可分为基于时间片抢占和立即抢占

#### 最早截止时间优先EDF

##### 非抢占式用于非周期任务

![image-20250102215347948](./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0.assets/image-20250102215347948.png)

##### 抢占式用于周期任务

![image-20250102215409927](./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0.assets/image-20250102215409927.png)

#### 最低松弛度优先

主要由于抢占式

$ 松弛度=必须完成时间-剩余未运行时长-当前时间 $

松弛度越低，优先级越高；松弛度为0时需立即抢占

### 死锁

死锁的必要条件：

- 互斥条件
- 请求和保持条件
- 不可抢占条件
- 循环等待条件

处理死锁的方法

- 预防
- 避免
- 检测
- 解除

#### 银行家算法

为了实现银行家算法，在系统中必须设置这样四个数据结构，分别用来描述系统中可利用的资源、所有进程对资源的最大需求、系统中的资源分配，以及所有进程还需要多少资源的情况。
 　(1) 可利用资源向量Available。
 　(2) 最大需求矩阵Max。
 　(3) 分配矩阵Allocation。
 　(4) 需求矩阵Need。

设Requesti是进程Pi的请求向量，如果Requesti[j]=K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查：
 　(1) 如果Requesti[j]≤Need[i, j]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。
 　(2) 如果Requesti[j]≤Available[j]，便转向步骤(3)； 否则，表示尚无足够资源，Pi须等待。

(3) 系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：
    　Available[j] = Available[j] - Requesti[j];
  　Allocation[i, j] = Allocation[i, j] + Requesti[j];
  　　Need[i, j] = Need[i, j] - Requesti[j];
 　(4) 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才**正式**将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。

#### 银行家安全性算法

(1) 设置两个向量：
        ① 工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work:= Available；
       ② Finish：它表示系统是否有足够的资源分配给进程，使之运行完成。
         开始时先做Finish[i]:= false；
         当有足够资源分配给进程时，再令Finish[i]:= true。

(2) 从进程集合中找到一个能满足下述条件的进程： 
 　① Finish[i]=false;
 　② Need[i, j]≤Work[j];
 　若找到，执行步骤(3)，否则，执行步骤(4)。
 　(3) 当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：
 　　　Work[j] = Work[j]+Allocation[i, j];
 　　　Finish[i] =true;
 　　　go to step 2;
 　(4) 如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。

## 存储器管理

### 伙伴系统

　　在伙伴系统中，对于一个大小为2k，地址为x的内存块，其伙伴块的地址则用buddyk(x)表示，其通式为：

![image-20250102225327007](./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0.assets/image-20250102225327007.png)
